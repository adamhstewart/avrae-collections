<drac2>
al_name = 'scroll'
footer = f'!{al_name} | Alias by @silverbass#2407'

# Load spell data from GVAR
g = load_json(get_gvar("7bc1042b-a670-47ce-afc0-4e78716772ee"))
spells = g.spells

# Get spell name from args
spname = "&1&"
args = &ARGS&

# Find matching spell (exact match first, then partial match)
matches = [x for x in spells if spname.lower() == x.name.lower()]
if not matches:
    matches = [x for x in spells if spname.lower() in x.name.lower()]
scroll = matches[0] if matches else None

# Show help if no spell specified
if not scroll:
    return f'embed -color {color} -thumb {image} -title "Spell Scroll" -desc "Using a Scroll: `!{al_name} [spell name]` - Accepts all the same args as `!cast`\n\n**2024 Rules:**\n• Spell must be on your spell list to use\n• If higher level than you can cast, roll DC 10 + spell level\n• On failure, scroll is consumed with no effect" -footer "{footer}"'

# 2024 Spell Scroll tables by spell level (0-9)
dc_table = [13, 13, 13, 15, 15, 17, 17, 18, 18, 19]
attack_bonus_table = [5, 5, 5, 7, 7, 9, 9, 10, 10, 11]
scroll_dc = dc_table[scroll.level]
scroll_attack_bonus = attack_bonus_table[scroll.level]

# Check if spell is on character's spell list
def get_spell_list_classes():
    """Returns list of classes that have this spell and the character has levels in."""
    ch = character()
    # Get subclass info from classinfo alias format: {"WizardLevel": "Evocation", ...}
    subclasses = load_json(get("subclass", "{}"))
    matching_classes = []

    for cls in scroll.classes:
        if "(" in cls:
            # Subclass-specific spell, e.g. "Cleric (Arcana Domain)"
            cls_name = cls.split(" ")[0]
            # Extract subclass name from parentheses
            required_subclass = cls.split("(")[1].rstrip(")")
            cls_level = ch.levels.get(cls_name, 0)
            char_subclass = subclasses.get(f"{cls_name}Level", "")
            if cls_level > 0 and char_subclass == required_subclass:
                matching_classes.append((cls_name, cls_level))
        else:
            # Regular class spell
            cls_name = cls.strip()
            cls_level = ch.levels.get(cls_name, 0)
            if cls_level > 0:
                matching_classes.append((cls_name, cls_level))
    return matching_classes

# Get character's spellcasting classes that have this spell
spell_list_classes = get_spell_list_classes()

# If spell is not on any of character's spell lists, it's unintelligible
if not spell_list_classes and "-i" not in args:
    return f'embed -color {color} -thumb {image} -title "{name} examines a Scroll of {scroll.name}..." -desc "The scroll is **unintelligible** - this spell is not on your spell list.\n\n**Classes that can use this scroll:** {", ".join(scroll.classes)}" -footer "{footer}"'

# Calculate highest spell level the character can cast from their matching classes
def max_castable_level(cls_name, cls_level):
    # Full casters: level / 2 rounded up (level 1 = 1st, level 3 = 2nd, etc.)
    # This is a simplification - could be expanded for half/third casters
    return min(9, (cls_level + 1) // 2)

can_cast_at_level = any(max_castable_level(cls, lvl) >= scroll.level for cls, lvl in spell_list_classes)

# Determine if check is needed
# -i flag bypasses the check (for DM override)
no_check_needed = "-i" in args or can_cast_at_level

# Build output
remaining_args = " ".join(args[1:]) if len(args) > 1 else ""

if no_check_needed:
    # Auto-success: spell is on list and character can cast at this level
    mod = scroll_dc - 8 - proficiencyBonus
    return f'cast "{scroll.name}" -i -dc {scroll_dc} -mod {mod} -b {scroll_attack_bonus - proficiencyBonus - spell} {remaining_args} -title "{name} uses a Scroll of {scroll.name}!" -f "{g.text}\n\n**Classes:** {", ".join(scroll.classes)}\n**Scroll Save DC:** {scroll_dc} | **Attack Bonus:** +{scroll_attack_bonus}" -footer "{footer}"'
else:
    # Spell is on list but higher level than character can cast - need ability check
    check_dc = 10 + scroll.level
    check = vroll(f"1d20+{spell}")

    if check.total >= check_dc:
        # Success!
        mod = scroll_dc - 8 - proficiencyBonus
        return f'cast "{scroll.name}" -i -dc {scroll_dc} -mod {mod} -b {scroll_attack_bonus - proficiencyBonus - spell} {remaining_args} -title "{name} uses a Scroll of {scroll.name}!" -f "{g.text}\n\n**Classes:** {", ".join(scroll.classes)}\n**Ability Check (DC {check_dc}):** {check}; **Success!**\n**Scroll Save DC:** {scroll_dc} | **Attack Bonus:** +{scroll_attack_bonus}" -footer "{footer}"'
    else:
        # Failure - scroll consumed with no effect
        return f'embed -color {color} -thumb {image} -title "{name} fails to use a Scroll of {scroll.name}!" -desc "The spell disappears from the scroll with no effect." -f "{g.text}\n\n**Classes:** {", ".join(scroll.classes)}\n**Ability Check (DC {check_dc}):** {check}; **Failure!**" -footer "{footer}"'
</drac2>
